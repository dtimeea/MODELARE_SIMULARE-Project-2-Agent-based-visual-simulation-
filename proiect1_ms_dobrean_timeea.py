# -*- coding: utf-8 -*-
"""Proiect1_MS_Dobrean_Timeea.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UhBUzac6V8pacN9vMP9EPo2UvO-Oi72C

# Lab 4: Enhancing the Bike Sharing System

Welcome to **Lab 4** of the Modeling & Simulation course! In this laboratory session, we will build upon the foundations laid in the previous labs to enhance our bike-sharing system simulation. This lab introduces the concept of **time slot-specific probabilities**, allowing you to model varying bike usage patterns throughout the day. Additionally, you will implement bike maintenance and downtime, develop a rebalancing mechanism, track customer satisfaction, and undertake a **graded assignment** to design and implement a comprehensive simulation project.

---

## Table of Contents

1. [Recap of Previous Labs](#recap)
2. [Introduction to Time Slot-Specific Probabilities](#time-slots)
   - [Understanding Time Slots](#understanding-time-slots)
3. [Implementing Time Slot-Specific Probabilities](#implementing-time-slots)
   - [Defining Time Slots](#defining-time-slots)
4. [Graded Assignment Overview](#assignment)

---

## <a name="recap"></a>1. Recap of Previous Labs

### Lab 1: Python Introduction
- Gained proficiency in Python programming.
- Learned fundamental programming concepts such as variables, data types, control structures, functions, and basic I/O operations.

### Lab 2: Basic Bike Sharing System Modeling
- Developed a simplified bike-sharing system using Python classes.
- Modeled entities such as stations, bikes, and trips.
- Implemented basic trip generation and analyzed system behavior over a short period.

### Lab 3: Introduction to SimPy
- Introduced SimPy, a discrete-event simulation library in Python.
- Reimplemented the bike-sharing system using SimPy constructs like environments, processes, and resources.
- Explored extensions including variable trip durations, rebalancing strategies, and customer satisfaction tracking.

---

## <a name="time-slots"></a>2. Introduction to Time Slot-Specific Probabilities

In real-world scenarios, bike usage varies throughout the day. To simulate this variability, we introduce **time slot-specific probabilities**. This enhancement allows the simulation to reflect different demand levels during various periods, such as morning rush hours and midday.

### <a name="understanding-time-slots"></a>Understanding Time Slots

- **Time Slots:** Defined periods within a day where bike trip probabilities differ.
- **Recurring Pattern:** Time slots repeat every simulated day, enabling multi-day simulations.
- **Example Time Slots:**
  - **Morning Start (0-120 minutes):** Initial hours with increasing demand.
  - **Midday (120-720 minutes):** Peak hours with stable high demand.

### <a name="mapping-time"></a>Mapping Simulation Time to Real-Time

To create realistic simulations, map simulation minutes to actual day times.

- **Simulation Start Time:** 6:00 AM
- **Morning Start:** 6:00 AM - 8:00 AM (0-120 minutes)
- **Midday:** 8:00 AM - 6:00 PM (120-720 minutes)
- **Simulation Duration:** 20 days (12 hours/day) → 14400 minutes

---

## <a name="implementing-time-slots"></a>3. Implementing Time Slot-Specific Probabilities

### <a name="defining-time-slots"></a>Defining Time Slots

Define time slots with specific trip probability matrices within a single day. Use the modulo operation to map the current simulation time to the appropriate time slot.

```python
# Define time slots for a single day
time_slots = [
    {
        'name': 'morning_start',
        'start': 0,       # 0 minutes into the day (6:00 AM)
        'end': 120,       # 2 hours
        'prob_matrix': {
            ('A', 'B'): 0.4,
            ('B', 'A'): 0.6,
            ('A', 'C'): 0.2,
            ('C', 'A'): 0.5,
            ('B', 'C'): 0.3,
            ('C', 'B'): 0.4,
            ('A', 'D'): 0.3,
            ('D', 'A'): 0.2,
        }
    },
    {
        'name': 'midday',
        'start': 120,      # 2 hours into the day (8:00 AM)
        'end': 720,        # 12 hours total (6:00 PM)
        'prob_matrix': {
            ('A', 'B'): 0.2,
            ('B', 'A'): 0.3,
            ('A', 'C'): 0.1,
            ('C', 'A'): 0.2,
            ('B', 'C'): 0.25,
            ('C', 'B'): 0.35,
            ('A', 'D'): 0.15,
            ('D', 'A'): 0.25,
        }
    }
    # Add more time slots if needed
]

# Define default probability matrix if no slot matches
default_prob_matrix = {
    ('A', 'B'): 0.05,
    ('B', 'A'): 0.05,
    ('A', 'C'): 0.05,
    ('C', 'A'): 0.05,
    ('B', 'C'): 0.05,
    ('C', 'B'): 0.05,
    ('A', 'D'): 0.05,
    ('D', 'A'): 0.05,
}
"""

# Start from the code you've implemented in lab 3, add time-slot specific probabilities below

"""## <a name="assignment"></a>Graded Assignment Overview

Design and implement an enhanced bike-sharing system simulation using **SimPy**, incorporating advanced features to model a realistic and complex environment. Your simulation should build upon the concepts learned in previous labs and include the following components:

---

Your simulation must include the following elements:

### 1. Multiple Stations:

- **Minimum of Four stations** with varying capacities and initial bike counts.
- Each station should have a unique name, capacity, and initial number of bikes.

### 2. Time-Dependent Trip Probabilities:

- Implement trip probabilities that change based on different time slots (e.g., morning start, midday).
- Define at least **two distinct time slots** with different probability matrices.
- Ensure that time slots are **recurring daily** over the simulation period.

### 3. Bike Maintenance and Downtime:

- Model bike failures with a specified failure probability during trips.
- Implement a repair process that handles broken bikes, making them unavailable until repaired. The implementation details are up to your imagination.
- Track and report the number of bikes under maintenance.

### 4. Rebalancing Mechanism:

- Develop a rebalancing strategy to redistribute bikes between stations based on current demand and bike levels.
- Rebalancing should occur at regular intervals (e.g., every 20 minutes) and follow defined criteria.

### 5. Customer Satisfaction Tracking:

- Track the number of **unhappy customers** who cannot rent a bike due to unavailability.
- Track the number of **unhappy customers** who cannot return a bike due to full stations.

### 6. Data Collection and Visualization:

- Collect data on **bike levels** at each station over time.
- Collect data on **broken bikes** and maintenance activities.
- Collect data on **customer satisfaction** metrics.
- Generate plots to visualize:
  - **Bike levels** at each station over time.
  - **Number of bikes under maintenance**.
  - **Customer satisfaction metrics** (e.g., unhappy customers over time).

### 7. Simulation:

- Allow the simulation to run for a configurable duration (e.g., **20 days**).
- Parameters such as the number of stations, capacities, initial bikes, trip probabilities, maintenance rates, rebalancing intervals, and simulation duration should be easily adjustable.
- Simulate and observe the system with various parameters.

---

#### (Optional) Money Earning Mechanism:

- Introduce a system where the bike-sharing service earns **money based on bike rentals** (e.g., per hour rented).
- Track and report **total earnings** over the simulation period.

## What to Look For in Your Simulations

The primary objective of this lab is to enable you to create a realistic and dynamic simulation of a bike-sharing system that accounts for daily usage patterns, system maintenance, and operational strategies. Things to look for:

* Bike Availability: Assess how well the rebalancing mechanism maintains adequate bike levels across stations.
* Maintenance Impact: Evaluate the effect of bike failures on system performance and customer satisfaction.
* Customer Satisfaction: Analyze the number of unhappy customers and identify patterns or causes.

Write down a couple of observations from your simulations to accompany the presentation of your system.

## Grading

You will present your work in the upcoming laboratory, showing your system implementation and 1-3 simulations that you ran. The simulations should be accompanied by visual plots and you are encouraged to present any interesting observations about your system (e.g. with environment setup X the customer dissatisfaction drops significantly when increasing the rebalancing frequency to value y).

The project grade will be determined by the grade of completion of your system (how much of the project task has been implemented), as well as your understanding of it. The latter will be assessed through some basic questions about your model/system/simulations.

*Note: Where not strongly specified, you are free to design a subsystem/idea however you find best fit, e.g. points 2, 3 and 4 can have many different subsystem designs. There is no one correct way to do it.
"""

!pip install simpy

import simpy
import random
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from dataclasses import dataclass
from typing import List

RANDOM_SEED = 42
DAYS = 20
MINUTES_PER_DAY = 24 * 60
SIM_DURATION = DAYS * MINUTES_PER_DAY

STATIONS_DEF = [
    ("UPT", 25, 12),
    ("CENTRU", 35, 18),
    ("MEDICINA", 30, 10),
    ("UVT", 20, 8),
]

SLOTS = [
    (6 * 60, "dimineata"),
    (10 * 60, "pranz"),
    (17 * 60, "seara"),
    (22 * 60, "noapte"),
]

DEPARTURE_RATES_PER_SLOT = {
    "dimineata": [30, 25, 15, 10],
    "pranz":     [20, 18, 12, 8],
    "seara":     [28, 20, 16, 12],
    "noapte":    [4, 3, 2, 1],
}


P_MATRIX_PER_SLOT = {
    "dimineata": np.array([
        [0.05, 0.55, 0.30, 0.10],
        [0.20, 0.05, 0.50, 0.25],
        [0.40, 0.35, 0.05, 0.20],
        [0.25, 0.40, 0.25, 0.10],
    ]),
    "pranz": np.array([
        [0.10, 0.30, 0.40, 0.20],
        [0.25, 0.10, 0.50, 0.15],
        [0.35, 0.25, 0.10, 0.30],
        [0.30, 0.25, 0.25, 0.20],
    ]),
    "seara": np.array([
        [0.15, 0.40, 0.25, 0.20],
        [0.10, 0.20, 0.25, 0.45],
        [0.15, 0.30, 0.10, 0.45],
        [0.10, 0.35, 0.20, 0.35],
    ]),
    "noapte": np.array([
        [0.40, 0.20, 0.25, 0.15],
        [0.35, 0.15, 0.30, 0.20],
        [0.30, 0.25, 0.25, 0.20],
        [0.25, 0.25, 0.30, 0.20],
    ]),
}

TRIP_TIME_TRIANG = (5, 15, 30)  # minute

FAILURE_PROB = 0.04

NUM_MECHANICS = 3
REPAIR_TIME_TRIANG = (20, 45, 150)

#RECONFIGURARE
REBALANCE_INTERVAL = 120        # minute
TARGET_FILL_RATIO = 0.55
THRESHOLD = 0.25
TRUCK_CAPACITY_PER_ROUND = 4

SAMPLE_EVERY = 30

ENABLE_REVENUE = True
REVENUE_PER_HOUR = 2.5  #lei/ora

def triangular(a, c, b):
    return random.triangular(a, b, c)

def minute_of_day(t):
    return int(t % MINUTES_PER_DAY)

def current_slot(t):
    m = minute_of_day(t)
    starts = sorted(SLOTS, key=lambda x: x[0])
    keys = [k for _, k in starts]
    starts_only = [s for s, _ in starts]
    idx = 0
    for i, s in enumerate(starts_only):
        if m >= s:
            idx = i
    return keys[idx] if m >= starts_only[0] else keys[-1]

def choose_destination(slot_key, origin_idx):
    probs = P_MATRIX_PER_SLOT[slot_key][origin_idx]
    return int(np.random.choice(len(probs), p=probs))

@dataclass
class Station:
    name: str
    capacity: int
    bikes: simpy.Container

#simularea
class BikeSharingSim:
    def __init__(self, env, stations_def):
        self.env = env
        random.seed(RANDOM_SEED)
        np.random.seed(RANDOM_SEED)

        self.stations: List[Station] = []
        for name, cap, init in stations_def:
            c = simpy.Container(env, init=init, capacity=cap)
            self.stations.append(Station(name, cap, c))

        self.unhappy_renters = 0
        self.unhappy_returners = 0
        self.maintenance_in_system = 0
        self.completed_trips = 0
        self.total_rental_minutes = 0.0

        self.history_time = []
        self.history_levels = {st.name: [] for st in self.stations}
        self.history_maint = []
        self.history_unhappy_renters = []
        self.history_unhappy_returners = []

        self.repair_store = simpy.Store(env)
        self.mechanics = simpy.Resource(env, capacity=NUM_MECHANICS)

        for idx, _ in enumerate(self.stations):
            env.process(self.customer_arrivals_process(idx))
        env.process(self.repair_dispatcher())
        env.process(self.rebalance_process())
        env.process(self.sampler())

    def sampler(self):
        while True:
            self.history_time.append(self.env.now)
            for st in self.stations:
                self.history_levels[st.name].append(int(st.bikes.level))
            self.history_maint.append(self.maintenance_in_system)
            self.history_unhappy_renters.append(self.unhappy_renters)
            self.history_unhappy_returners.append(self.unhappy_returners)
            yield self.env.timeout(SAMPLE_EVERY)

    def rebalance_process(self):
        while True:
            yield self.env.timeout(REBALANCE_INTERVAL)
            surplus, deficit = [], []
            for st in self.stations:
                target = TARGET_FILL_RATIO * st.capacity
                dev = st.bikes.level - target
                if dev > THRESHOLD * st.capacity:
                    surplus.append((st, dev))
                elif dev < -THRESHOLD * st.capacity:
                    deficit.append((st, -dev))

            surplus.sort(key=lambda x: x[1], reverse=True)
            deficit.sort(key=lambda x: x[1], reverse=True)

            moves_left, s_idx, d_idx = TRUCK_CAPACITY_PER_ROUND, 0, 0
            while moves_left > 0 and s_idx < len(surplus) and d_idx < len(deficit):
                s_st, s_amt = surplus[s_idx]
                d_st, d_amt = deficit[d_idx]
                move = min(moves_left, int(round(min(s_amt, d_amt))))
                if move <= 0: break
                move = int(min(move, s_st.bikes.level, d_st.capacity - d_st.bikes.level))
                if move <= 0:
                    s_idx += 1; d_idx += 1
                    continue
                yield s_st.bikes.get(move)
                yield d_st.bikes.put(move)
                moves_left -= move

    def repair_dispatcher(self):
        while True:
            _ = yield self.repair_store.get()
            self.maintenance_in_system += 1
            with self.mechanics.request() as req:
                yield req
                yield self.env.timeout(triangular(*REPAIR_TIME_TRIANG))
            dest = min(self.stations, key=lambda st: (st.bikes.level / st.capacity))
            yield dest.bikes.put(1)
            self.maintenance_in_system -= 1

    def customer_arrivals_process(self, origin_idx):
        st = self.stations[origin_idx]
        while True:
            slot_key = current_slot(self.env.now)
            rate_per_hour = DEPARTURE_RATES_PER_SLOT[slot_key][origin_idx]
            rate_per_min = rate_per_hour / 60.0
            interarrival = 10.0 if rate_per_min <= 0 else random.expovariate(rate_per_min)
            yield self.env.timeout(interarrival)

            if st.bikes.level >= 1:
                yield st.bikes.get(1)
                dest_idx = choose_destination(slot_key, origin_idx)
                trip_minutes = triangular(*TRIP_TIME_TRIANG)
                self.total_rental_minutes += trip_minutes
                yield self.env.timeout(trip_minutes)
                if random.random() < FAILURE_PROB:
                    yield self.repair_store.put(st.name)
                else:
                    dest_st = self.stations[dest_idx]
                    if dest_st.bikes.level >= dest_st.capacity:
                        self.unhappy_returners += 1
                    yield dest_st.bikes.put(1)
                self.completed_trips += 1
            else:
                self.unhappy_renters += 1


def main():
    env = simpy.Environment()
    sim = BikeSharingSim(env, STATIONS_DEF)
    env.run(until=SIM_DURATION)

    print("\n SIMULARE SISTEM BIKE SHARING TIMISOARA ")
    print(f"Zile simulate: {DAYS}")
    print(f"Tranzactii finalizate: {sim.completed_trips}")
    print(f"Clienti fara bicicleta: {sim.unhappy_renters}")
    print(f"Clienti fara loc de returnare: {sim.unhappy_returners}")
    print(f"Varf biciclete in reparatie: {max(sim.history_maint)}")

    if ENABLE_REVENUE:
        ore = round(sim.total_rental_minutes / 60, 2)
        venit = round(ore * REVENUE_PER_HOUR, 2)
        print(f"Timp total inchiriat (ore): {ore}")
        print(f"Venit estimat: {venit} lei")

    #graf
    time_days = np.array(sim.history_time) / MINUTES_PER_DAY
    plt.figure(figsize=(12, 8))

    # Biciclete disponibile per statie
    for st_name, levels in sim.history_levels.items():
        plt.plot(time_days, levels, label=f"Statia {st_name}")
    plt.xlabel("Zile")
    plt.ylabel("Numar biciclete")
    plt.title("Evolutia numarului de biciclete in fiecare statie")
    plt.legend()
    plt.grid(True)
    plt.show()

    # Biciclete în reparatie
    plt.figure(figsize=(10, 5))
    plt.plot(time_days, sim.history_maint)
    plt.title("Biciclete aflate in reparatie in timp")
    plt.xlabel("Zile")
    plt.ylabel("Numar biciclete defecte")
    plt.grid(True)
    plt.show()

    # Clienti nefericiti
    plt.figure(figsize=(10, 5))
    plt.plot(time_days, sim.history_unhappy_renters, label="Fara bicicleta")
    plt.plot(time_days, sim.history_unhappy_returners, label="Fara loc liber")
    plt.xlabel("Zile")
    plt.ylabel("Numar clienti nefericiti (cumulat)")
    plt.title("Evolutia clientilor nefericiti")
    plt.legend()
    plt.grid(True)
    plt.show()

if __name__ == "__main__":
    main()